---
title: "SBC API Interface Introduction"
author: "Hyunji Moon, Martin ModrÃ¡k, Shinyoung Kim"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SBC Basic}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
library(SBC);
```
# SBC
## Introduction
SBC aims to extend `rstan::sbc()` to include support for new Simulation Based Calibration algorithms without the user having to hassle with
sampling or standardizing input/output. It provides utility functions which can ease sampling prior/posterior predictive distributions, along with
generic SBC plots, experimental features such as bootstrap/jacknife sampling, and integral probability metric based tests. 

As of now, `SBC` provides two interfaces, with the primary interface being the "api", featuring a fully customizable SBC pipeline from dataset to simulator for advanced users. A simpler interface through `workflow` is also provided which takes care of under-the-hood options, albeit at a cost of reduced flexibility.

This vignette will demonstrate how the `api` variant can be used to generate multiple SBC samples to calculate ranks.

## Basic API Architecture

The `api` is largely split into two components, `SBC_datasets` and `Backend` objects. `SBC_datasets` objects hold the simulated prior and data samples, which are then used during SBC to fit the model. Instead of directly creating a dataset object, users may define a `Generator` function that returns the parameters and simulated data for a single iteration. `SBC` can take the function and generate a dataset object for you through repeated calls of the `Generator`. Please refer to here for detailed specifications of `SBC_datasets` and `Generator` functions.

Once the `SBC_datasets` is prepared and loaded with the true prior and simulated data samples, `SBC` uses a `Backend` object to actually fit the model to the simulated data and generate posterior samples. In short, `Backend` bunches together the desired platform in which inference is ran(`cmdstanr`, `rstan`, `brms`, `pymc`, etc.), the model, and additional platform-specific inference parameters which are necessary to run inference for the model-platform combination.

Once the `SBC_datasets` and `Backend` objects are set up, running SBC and viewing results becomes as simple as a few function calls, greatly reducing the hassle with having to deal with extracting posterior draws and calculating results. Additionally, the results are stored in `posterior::rvars` format, which allows for easy manipulation and rapid calculation of additional metrics of interest.

## API Example - Simple Poisson Regression
In this vignette we will demonstrate how the `api` interface is used with a simple poisson regression model.

### API Example - Model Setup
We will be running SBC against a model that defines `y ~ Poisson(lambda)`, where `lambda ~ Gamma(15, 5)`. We will be using `cmdstanr` as the backend with the following model code:
```{r, include = TRUE}
stan_code <- "
data{
  int N;
  int y[N];
}
parameters{
  real<lower = 0> lambda;
}
model{
  lambda ~ gamma(15, 5);
  y ~ poisson(lambda);
}
"
cmdstan_model <- cmdstanr::cmdstan_model(cmdstanr::write_stan_file(stan_code))

```

### API Example - Generator

Once we bave defied the moddel, we can create a Generator function which will generate prior and data samples:
```{r}
# A generator function should return a named list containing elements "parameters" and "generated"

poisson_generator_single <- function(N){  # N is the number of data points we are generating
  lambda <- rgamma(n = 1, shape = 15, rate = 5)
  y <- rpois(n = N, lambda = lambda)
  list(
    parameters = list(
      lambda = lambda
    ),
    generated = list(
      N = N,
      y = y
    )
  )
}
```

As you can see, the `Generator` returns a named list containing randomly samples from the prior and generated data realized from the prior samples.

### API Example - Create `SBC_Datasets` from Generator
`SBC` provides helper functions `function_SBC_generator` and `generate_datasets` which takes a Generator function and creates a benign `SBC_datasets' object. 

```{r}
n_datasets <- 100  # Number of SBC iterations to run

poisson_generator <- function_SBC_generator(poisson_generator_single, N = 40)
poisson_dataset <- generate_datasets(
  poisson_generator, 
  n_datasets)
```


### API Example - Defining `Backend`
Once we have the model compiled we'll create a `Backend` object from the model. `SBC` includes pre-defined `Backend` objects for HMC sampling with `cmdstan` and `rstan`. In addition, it also provides generator function and Backend for `brms` based models. 

Note that you can create your own `Backend` if you wish to use a different sampling/optimization platform, such as variational inference or JAGS. For further information on `Backend` specifications, please refer to here.

Here we'll just use the pre-defined cmdstan Backend, in which we pass our compiled model and any additional arguments we would like to pass over to `cmdstanr::sampling`:
```{r}
poisson_backend <- cmdstan_sample_SBC_backend(
    cmdstan_model, iter_warmup = 1000, iter_sampling = 1000)
```

### API Example - Computing Ranks
we can then use `compute_results` to fit our datasets with the backend:
```{r, results=FALSE}
results <- compute_results(poisson_dataset, poisson_backend)
```

### API Example - Viewing Results
We can now inspect the results to see if there were any errors and check individual stats:
```{r}
results$stats
```
### API Example - Plots
And finally, we can plot the rank distribution to check if the ranks are uniformly distributed. We can check the rank histogram and ECDF plots:

```{r}
plot_rank_hist(results)
```

```{r}
plot_ecdf(results)
```
```{r}
plot_ecdf_diff(results)
```
