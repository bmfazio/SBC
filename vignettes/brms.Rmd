---
title: "SBC for brms models"
output: html_notebook
---

```{r setup}
library(SBC)
library(brms)
library(ggplot2)
options(brms.backend = "cmdstanr")
#options(brms.backend = "rstan") # Uncomment to use rstan
```

```{r}
data = data.frame(y = rep(0, 15), x = rnorm(15))
priors <- prior(normal(0,1), class = "b") +
  prior(normal(0,1), class = "Intercept") +
  prior(normal(0,1), class = "sigma")
generator <- brms_SBC_generator(y ~ x, data = data, prior = priors)
#brms::get_prior(y ~ x, data = data, priors = prior(normal(0,1), class = "b"))                                
```

```{r}
datasets <- generate_datasets(generator, 20)
```

```{r}
# Reuse the compiled model and other info from the generator
backend <- brms_SBC_backend_from_generator(generator, warmup = 500, iter = 1000, chains = 1,
                            init = 0.1)

# More verbose alternative:
#backend <- brms_SBC_backend(y ~ x, template_dataset = data, prior = priors, warmup = 500, iter = 1000, chains = 1,
#                            init = 0.1)
```

```{r}
results <- compute_results(datasets, backend, thin_ranks = 10)
```

```{r}
for(p in colnames(results$ranks)) {
  print(plot_ecdf_diff(results, p) + ggtitle(p))
}
```

## Using custom simulation code


Also allows to have different covariate values for each dataset, potentially improving sensitivity.

Let's take a Gaussian model with a single varying intercept.

```{r}
generate_single_dataset <- function(N, K) {
  stopifnot(K <= N)
  x <- rnorm(N) + 10
  
  group <- sample(1:K, size = K, replace = TRUE)
  # Ensure all groups are actually present
  if(length(unique(group)) < K) {
    group[1:K] <- 1:K
  }
  
  b_Intercept <- rnorm(1, 5, 1)   
  b_x <- rnorm(1, 0, 1)
  
  sd_group__Intercept <- abs(rnorm(1, 0, 0.75))
  r_group <- matrix(rnorm(K, 0, sd_group__Intercept), 
                 nrow = K, ncol = 1,
                 dimnames = list(1:K, "Intercept"))
  
  sigma <- abs(rnorm(1, 0, 3))
  
  predictor <- b_Intercept + x * b_x + r_group[group]
  y <- rnorm(N, predictor, sigma)
  
  list(
    parameters = list(
      b_Intercept = b_Intercept,
      b_x = b_x,
      sd_group__Intercept = sd_group__Intercept,
      r_group = r_group,
      sigma = sigma
    ),
    generated = data.frame(y = y, x = x, group = group)
  )
}

generator_func <- function_SBC_generator(generate_single_dataset, N = 12, K = 3)
```


```{r}
set.seed(12239755)
datasets_func <- generate_datasets(generator_func, 100)
```

```{r}
priors_func <- prior(normal(0,1), class = "b") +
  prior(normal(5,1), class = "Intercept") +
  prior(normal(0,5), class = "sigma") +
  prior(normal(0,0.75), class = "sd")


backend_func <- brms_SBC_backend(y ~ x + (1 | group),  
                            prior = priors_func, chains = 1,
                            template_dataset = datasets$generated[[1]],
                            generator = generator_func)

```

```{r}
results_func <- compute_results(datasets_func, backend_func, thin_ranks = 10)
```

```{r}
for(p in colnames(results_func$ranks)) {
  print(plot_ecdf_diff(results_func, p) + ggtitle(p))
}
```

What happened is that `brms` by default centers all the predictors, which changes the
numerical values of the intercept (but not other terms) using `0 + Intercept` syntax avoids this. 


```{r}
priors_func2 <- prior(normal(0,1), class = "b") +
  prior(normal(5,1), class = "b", coef = "Intercept") +
  prior(normal(0,5), class = "sigma") +
  prior(normal(0,0.75), class = "sd")


backend_func2 <- brms_SBC_backend(y ~ 0 + Intercept + x + (1 | group),  
                            prior = priors_func2, warmup = 500, iter = 1000, chains = 1,
                            template_dataset = datasets_func$generated[[1]],
                            generator = generator_func)


```

```{r}
results_func2 <- compute_results(datasets_func, backend_func2, thin_ranks = 10)
```

We see that this results in non-problematic univariate checks.

```{r}
for(p in colnames(results_func2$ranks)) {
  print(plot_ecdf_diff(results_func2, p) + ggtitle(p))
}
```


